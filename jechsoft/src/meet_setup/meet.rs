use super::{
    australian_world_record::{AustralianRank, AustralianWorldRecord},
    award::Award,
    competition_type::CompetitionType,
    deserializer,
    distance::Distance,
    event::Event,
    person::Person,
    pool_category::PoolCategory,
    qualification_set::QualificationSet,
    session::Session,
    touch_pad_set::TouchPadSet,
};
use chrono::NaiveDate;
use datetime::Year;
use reqwest::Url;
use serde::Deserialize;
use serde_email::Email;
use std::error::Error;
use std::{fs::File, io::BufReader, path::Path};

/// `MeetConfig` is a rust structure that represents `meetsetup.xml` file from Jechsoft Victoria.
/// This file seems to be a simple settings dump from the application.
/// TODOs:
/// - [ ] Refactor pub products: Vec<(String, Price)>. Look at #[serde(flatten)]
/// - [ ] Use money package for deserializing currency like [rusty money](https://docs.rs/rusty-money/latest/rusty_money/)
/// - [ ] Group together configuration for heat list generation
/// - [ ] Group together configuration for scheduling
#[derive(Deserialize, Debug)]
#[serde(rename = "MeetSetUp", rename_all = "PascalCase")]
#[allow(clippy::struct_excessive_bools)]
#[serde(deny_unknown_fields)]
pub struct Meet {
    /// Jechsoft meet config version
    pub nsf_version: String,

    /// Parsed config was generated by this software
    pub creator: String,

    /// Norwegian swimming federation meet id (nsfid). 10 digit id with leading zeros
    #[serde(rename = "NSFMeetId")]
    pub nsf_meet_id: Option<u32>,

    /// Meet name.
    #[serde(rename = "MeetName")]
    pub name: String,

    /// readable representation of the date.
    #[serde(rename = "MeetDate")]
    pub date: String,

    /// Location of the meet.
    #[serde(rename = "MeetPlace")]
    pub location: String,

    pub pool_category: PoolCategory,

    /// Pool length
    pub pool_length: Distance,

    pub start_with_lane: Option<u8>,

    /// Number of lanes in the competition.
    pub lanes: u8,

    /// Enrollment price in NOK for one enrollment entry for one athlete.
    pub individual_price: u16,

    /// Enrollment price in NOK for one enrollment entry for one relay team.
    pub team_price: u16,

    pub individual_price2: u16,

    pub team_price2: u16,

    /// Enrollment price in NOK for athletes that qualify for paying one price for unlimited entries.
    pub one_price_all: u16,

    // Athlete with this birth year pays once for unlimited starts.
    #[serde(
        rename = "OnePriceAllClasses",
        deserialize_with = "deserializer::one_price_all_class",
        default
    )]
    pub birth_years_pay_once: Option<Vec<Year>>,

    #[serde(deserialize_with = "deserializer::bool")]
    pub australian_model: bool,

    pub australian_rank: AustralianRank,

    pub australian_world_record: AustralianWorldRecord,

    /// Merge all handicap classes into one single handicap class.
    #[serde(rename = "HCSingleAgeGroup", deserialize_with = "deserializer::bool")]
    pub hc_single_age_group: bool,

    /// Female athletes born this year or earlier (older athletes) are competing in senior class.
    #[serde(default, deserialize_with = "deserializer::option_year")]
    pub women_senior: Option<Year>,

    #[serde(default)]
    pub extra_time_backstroke: Option<u8>,

    /// Male athletes born this year or earlier (older athletes) are competing in senior class.
    #[serde(
        default,
        alias = "menSenior",
        deserialize_with = "deserializer::option_year"
    )]
    pub men_senior: Option<Year>,

    // TODO: men: [Option<Year>; 2];
    // TODO: women: [Option<Year>; 2];
    #[serde(default, deserialize_with = "deserializer::option_year")]
    pub women_junior: Option<Year>,

    #[serde(default, deserialize_with = "deserializer::option_year")]
    pub men_junior: Option<Year>,

    #[serde(default, deserialize_with = "deserializer::option_year")]
    pub women_junior2: Option<Year>,

    #[serde(default, deserialize_with = "deserializer::option_year")]
    pub men_junior2: Option<Year>,

    #[serde(default, deserialize_with = "deserializer::option_year")]
    pub women_youngest_final: Option<Year>,

    #[serde(default, deserialize_with = "deserializer::option_year")]
    pub men_youngest_final: Option<Year>,

    /// If true then the meet is primarily a masters meet.
    #[serde(deserialize_with = "deserializer::bool")]
    pub primary_masters: bool,

    /// Enrollment with personal best has to be no later than this date.
    #[serde(deserialize_with = "deserializer::date")]
    pub final_entry_date: NaiveDate,

    /// Enrollment with personal best has to be no older than this date.
    #[serde(deserialize_with = "deserializer::date")]
    pub first_entry_date: NaiveDate,

    /// Last enrollment date.
    #[serde(deserialize_with = "deserializer::date")]
    pub last_entry_date: NaiveDate,

    /// If true, qualifications don't apply for handicapped athletes.
    #[serde(rename = "NoQualHC", deserialize_with = "deserializer::bool")]
    pub no_qual_hc: bool,

    /// Date meet start.
    #[serde(
        default,
        rename = "StartDate",
        deserialize_with = "deserializer::option_date"
    )]
    pub date_start: Option<NaiveDate>,

    /// Date meet end.
    #[serde(
        default,
        rename = "EndDate",
        deserialize_with = "deserializer::option_date"
    )]
    pub date_end: Option<NaiveDate>,

    /// Host club.
    pub host_club: Option<String>,

    /// Organization number of host club.
    /// Samples:
    /// - "GR01040025450"
    /// - "GR03010168450"
    /// - "GR04270045450"
    /// - "GR06170001450"
    /// - "GR07010020450"
    /// - "GR07060028450"
    /// - "GR11030050450"
    /// - "GR15340002450"
    /// - "GR18330025450"
    ///
    /// Starts always with "GR" and then 11 numbers with leading zeros.
    pub host_club_organization_no: Option<String>, // TODO: create struct for this type

    pub competition_type_id: CompetitionType,

    pub community: Option<String>,

    /// Human readable string representation of the meet. Might be redundant because of `competition_type_id`.
    pub competition_type: String,

    /// Url to where results can be found.
    #[serde(default, rename = "ResultWebaddress")]
    pub result_web_address: Option<Url>,

    /// homepage
    #[serde(default, rename = "Homepage")]
    pub home_page: Option<Url>,

    /// enrollment email address
    // BUG: deserializes to None all the time
    #[serde(default, alias = "MailPameldinger", alias = "EntryMail")]
    pub entry_email: Option<Email>,

    /// Payment information for clubs.
    #[serde(default)]
    pub pay_account: String,

    #[serde(default, deserialize_with = "deserializer::option_bool")]
    pub general_senior: Option<bool>,

    #[serde(default, deserialize_with = "deserializer::option_bool")]
    pub general_junior: Option<bool>,

    #[serde(
        default,
        rename = "GeneralHC",
        deserialize_with = "deserializer::option_bool"
    )]
    pub general_hc: Option<bool>,

    #[serde(default, deserialize_with = "deserializer::option_bool")]
    pub general_masters: Option<bool>,

    #[serde(default, deserialize_with = "deserializer::option_bool")]
    pub no_pool: Option<bool>,

    /// If true then the meet has been cancelled.
    #[serde(deserialize_with = "deserializer::bool")]
    pub cancelled: bool,

    /// Optional info box in meet configuration.
    #[serde(default)]
    pub info: Option<String>,

    #[serde(deserialize_with = "deserializer::bool")]
    pub write_country: bool,

    #[serde(rename = "RecordsInHeatlist", deserialize_with = "deserializer::bool")]
    pub records_in_heat_list: bool,

    #[serde(default, deserialize_with = "deserializer::option_bool")]
    pub write_first_lap: Option<bool>,

    #[serde(
        rename = "PageNumberInHeatlist",
        deserialize_with = "deserializer::option_bool"
    )]
    pub page_number_in_heat_list: Option<bool>,

    #[serde(
        default,
        deserialize_with = "deserializer::option_bool",
        alias = "Skriv1etappe"
    )]
    pub write_first_stage: Option<bool>,

    #[serde(deserialize_with = "deserializer::bool")]
    pub use_group_text: bool,

    #[serde(deserialize_with = "deserializer::bool")]
    pub show_time_schedule: bool,

    #[serde(deserialize_with = "deserializer::bool")]
    pub show_time_only_heat_one: bool,

    #[serde(deserialize_with = "deserializer::bool")]
    pub show_heat_text: bool,

    /// Touch pad configuration.
    #[serde(rename = "Touchpads", deserialize_with = "deserializer::touch_pad_set")]
    pub touch_pads: Option<TouchPadSet>,

    #[serde(deserialize_with = "deserializer::bool")]
    pub write_other_prices: bool,

    /// If true non of the results will be reported to national record database.
    #[serde(deserialize_with = "deserializer::bool")]
    pub unofficial: bool,

    /// TODO: products: HashMap<String, Price>
    #[serde(default)]
    pub other_payment1: Option<String>,

    #[serde(default)]
    pub other_price1: Option<u16>,

    #[serde(default)]
    pub other_payment2: Option<String>,

    #[serde(default)]
    pub other_price2: Option<u16>,

    #[serde(default)]
    pub other_payment3: Option<String>,

    #[serde(default)]
    pub other_price3: Option<u16>,

    #[serde(deserialize_with = "deserializer::bool")]
    pub write_date_time: bool,

    pub header: Option<String>,

    pub footer: Option<String>,

    /// Default award configuration for the meet. This value is used if this.events.awards = Award::Default.
    #[serde(rename = "Prizes")]
    pub awards: Option<Award>,

    #[serde(default, deserialize_with = "deserializer::option_bool")]
    pub start_on_minute: Option<bool>,

    pub time_between: Option<u16>,

    pub extra_time: Option<u16>,

    /// List of sessions in the meet. A session is a set of continuos heats without breaks.
    #[serde(deserialize_with = "deserializer::session")]
    pub sessions: Vec<Session>,

    /// List of qualification requirements for enrollment.
    #[serde(default)]
    pub qualification_set: Option<QualificationSet>,

    /// Host representative for managing enrollment.
    #[serde(rename = "EntryManager")]
    pub entry_manager: Option<Person>,

    // #[serde(rename = "DefinedAgeGroups")]
    // pub age_groups: DefinedAgeGroups,
    /// Host representative for managing the meet. Also called "meet leader".
    #[serde(rename = "CompetitionManager")]
    pub competition_manager: Option<Person>,

    /// Events
    #[serde(deserialize_with = "deserializer::event")]
    pub events: Vec<Event>,
}

impl Meet {
    ///#  Errors
    /// returns Error if:
    /// - `local_xml_file` cannot be opened.
    /// - deserialization fails

    pub fn from(local_xml_file: &Path) -> Result<Self, Box<dyn Error>> {
        let file = File::open(local_xml_file)?;

        let reader = BufReader::new(file);

        let jd = &mut serde_xml_rs::de::Deserializer::new_from_reader(reader);
        Ok(serde_path_to_error::deserialize(jd)?)
    }
    /*
       pub fn get_issues(&self) -> Vec<String> {
           let mut issues = vec![];
           if self.cancelled {
               issues.push("meet is cancelled".into());
               return issues;
           }
           if self.nsf_meet_id.is_none() {
               issues.push("nsf meet id missing".into());
           }

           if self.date_start.is_none() {
               issues.push("missing start date".into());
           }

           if self.date_end.is_none() {
               issues.push("missing end date".into());
           }

           if let Some(date_start) = self.date_start {
               if let Some(date_end) = self.date_end {
                   if date_end < date_start {
                       issues.push("end date is before start date".into());
                   }
               }
           }

           // if organization number is set but host club is not and vise versa
           if self.host_club_organization_no.is_none() && self.host_club.is_some()
               || self.host_club_organization_no.is_some() && self.host_club.is_none()
           {
               issues.push("mismatch between host club and organization number".into());
           }

           for session_issue in self.get_session_issues() {
               issues.push(session_issue);
           }
           for event_issue in self.get_event_issues() {
               issues.push(event_issue);
           }

           for class_issue in self.get_class_issues() {
               issues.push(class_issue);
           }

           for qualification_issue in self.get_qualification_issues() {
               issues.push(qualification_issue);
           }

           for age_group_issue in self.get_age_group_issues() {
               issues.push(age_group_issue);
           }

           issues
       }

       fn get_age_group_issues(&self) -> Vec<String> {
           let mut issues = vec![];
           // TODO
           // if let Some(age_groups) = &self.age_groups {
           //     for age_group in age_groups {
           //         for year in age_group.groups {}
           //     }
           // }
           issues
       }

       fn get_qualification_issues(&self) -> Vec<String> {
           let mut issues = vec![];
           if let Some(qualification_set) = &self.qualification_set {
               for qualification in &qualification_set.qualifications {
                   // // calculate the speed
                   // // if the speed is outside of a certain rage, then it's most likely a bug.
                   // let speed: u8 =
                   //     qualification.distance.into() / qualification.qualification_time.into();
               }
           }
           issues
       }

       fn get_class_issues(&self) -> Vec<String> {
           let mut issues = vec![];
           if let Some(birth_years_that_pay_once) = &self.birth_years_pay_once {
               // check outside of required range
               // TODO: use year of the meet not current year
               let meet_year = Year(Local::now().year().into()).abs();
               for birth_year in birth_years_that_pay_once {
                   let age = birth_year.abs() - meet_year;
                   if !(9..=10).contains(&age) {
                       issues.push(format!(
                           "class {} is not 9 or 10 years old at the start date of the meet",
                           birth_year.abs()
                       ));
                   }
               }

               // check that required classes are in the list
               let mut nine_yo = false;
               let mut ten_yo = false;
               for birth_year in birth_years_that_pay_once {
                   let age = birth_year.abs() - meet_year;
                   if 9 == age {
                       nine_yo = true;
                       continue;
                   }
                   if 10 == age {
                       ten_yo = true;
                       continue;
                   }
                   if nine_yo && ten_yo {
                       break;
                   }
               }
               if !nine_yo {
                   issues.push(
                       "missing class that pays one price that is 9 years old at the start date of the meet".into(),
                   );
               }
               if !ten_yo {
                   issues.push(
                       "missing class that pays one price that is 10 years old at the start date of the meet".into(),
                   );
               }
               // TODO: check for duplicates -> mismatch between duplicates.
           }
           // TODO: one price all class issues
           // Following issues required documentation about what those values mean
           // TODO: WomenSenior
           // TODO: MenSenior
           // TODO: WomenJunior
           // TODO: MenJunior
           // TODO: WomenJunior2
           // TODO: MenJunior2
           // TODO: WomenYoungestFinal
           // TODO: MenYoungestFinal
           issues
       }

       fn get_event_issues(&self) -> Vec<String> {
           let mut issues = vec![];
           for event in &self.events {
               if !event.distance.is_official() {
                   issues.push(format!(
                       "event {} - unofficial distance: {} in official meet",
                       event.id, event.distance
                   ));
               }
           }
           issues
       }

       fn get_session_issues(&self) -> Vec<String> {
           // check that sessions start during the meet
           let mut issues = vec![];
           for session in &self.sessions {
               if let Some(meet_date_start) = self.date_start {
                   if let Some(meet_date_end) = self.date_end {
                       if session.date > meet_date_end {
                           issues.push(format!(
                               "session: {} start {} is after the meet end {}",
                               session.id, session.date, meet_date_start
                           ));
                       }
                       if session.date < meet_date_start {
                           issues.push(format!(
                               "session: {} start {} is before the meet start {}",
                               session.id, session.date, meet_date_start
                           ));
                       }
                   }
               }
           }
           issues
       }

    */
}
